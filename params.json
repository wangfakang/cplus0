{"name":"Cplus0","tagline":"stl analysis","body":"一：STL之空间配置器总结    \r\n===\r\n\r\n内存池的总结：      \r\n  首先要看用户需要的空间是否在128字节之内，若大于128，则直接使用一级空间配置器，直接进行内存分配，否则使用内存池：\r\n具体过程是：       \r\n\r\n```   \r\n1： 首先根据用户需求大小，把其调节成8的倍数，然后在16个自由空闲链表中去查找  \r\n(((bytes) + __ALIGN - 1) & ~(__ALIGN-1));   \r\n2：若找到则把那块从Free_list中分配给用户    \r\n((bytes + __ALIGN -1) / __ALIGN -1);    \r\n3：若恰好找到的那一块是NULL的，则调用refill(ROUND_UP(n))函数，refill函数的意思就是重新填充free_list链表，\r\n在STL中规定的是为ree_list为NULL的那块在内存池中选取20块对应大小的内存分配给他，调用chunk_alloc(n,nobjs)函数，\r\n当内存池无法满足分配20块的时候则最少就要选取1块分配给他\r\n\r\n4：倘若此时内存池中剩下的内存大小比用户所需内存类型的1块还小的时候，则重新开辟池子（使用malloc其大小为：\r\n用户所需大小的2倍加上池子以前总大小的十六分之一即：size_t types_to_get   =2*total_types + ROUND_UP(heap_size>>4);）\r\n\r\n5：若此时开辟失败则在free_list中为NULL的下一块开始选择一块不为NULL的分配给内存池，然后若是成功则递归调用\r\nchunk_alloc(n,nobjs)函数\r\n\r\n6：若此时还是不可以满足的话则调用一级空间配置器来分配（allocate(types_to_get)函数首先还是会直接调用malloc函数，\r\n然后当失败的时候就会调用oo_malloc函数，oo_malloc函数首先会检查my_malloc_handler函数指针是否是NULL，若NULL的话\r\n就直接抛出异常，否则调用my_malloc_handler函数（意思是看用户可不可以还一些内存给系统），然后再重新调用malloc函数）\r\n\r\n[是free_list中所存储的obj*]\r\n```\r\n\r\n\r\n\r\n二：STL之iterator类型的萃取技术总结：\r\n\r\n首先迭代器的继承层次：       \r\n\r\n   输入迭代器              输出迭代器        \r\n\r\n\r\n               正向迭代器\r\n\r\n               双向迭代器\r\n                 \r\n               随机迭代器\r\n              \r\n\r\n输入迭代器：所指之物不允许外界改变，只可以读只可以operator++     \r\n输出迭代器：只可以用于写  只可以operator++   \r\n正向迭代器：可以做读写操作  只可以operator++   \r\n双向迭代器：可以双向做读写操作  即可以重载operator++   operator—   \r\n随机迭代器：由于操作的内存是连续的所以不仅可以重载operator++   operator—    \r\n还可以p+n等   \r\n\r\n二：迭代器的类型的萃取技术   \r\n====\r\n\r\n* 1：为何产生此技术：    \r\n     其迭代器的类型的萃取技术主要用于一些算法里面比如insert当中以及copy，fill当中，\r\n     主要是根据迭代器所指之物的类型的构造函数是否是无关紧要的，如果是无关紧要则直接\r\n     进行移动（即有空间即可操作），否则要通过调用构造函数一个一个的进行构造，所以通\r\n     过迭代器的类型的萃取技术从而可以提高效率  \r\n\r\n（const_iterator 与iterator的区别：只是对所指之物的限定）\r\n``` c\r\nconst_reference operator*() const    \r\n{   \r\nreturn _Acc::_Value(_Ptr);   \r\n}\r\nreference operator*() const    \r\n{  \r\nreturn _Acc::_Value(_Ptr);  \r\n}   \r\n ```\r\n* 2：此技术是如何做到的\r\n\r\n   比方说是List中的迭代器，他是从Bidit双向迭代器继承过来的，而Bidit双向迭代器又是从\r\n   iterator鼻祖继承过来的，当List中迭代器实参推演的时候就会一层一层的向上推演，直到\r\n   鼻祖为止，而鼻祖iterator中把五中类型都进行了封装，然后通过iterator_traits得到迭代\r\n   器的类型，以及所指之物的类型  \r\n   \r\n``` c\r\ntemplate<class Category,class T,class Distance = ptrdiff_t,\r\n         class Pointer = T*,class Reference = T&>\r\nstruct iterator//是最传统的迭代器[只是所有迭代器的鼻祖]\r\n{\r\n    typedef Category  iterator_category;//指的是迭代器的类型\r\n    typedef T         value_type;//迭代器所指之物的类型\r\n\ttypedef Distance  difference_type;//差值类型\r\n\ttypedef Pointer   pointer;//指针类型\r\n\ttypedef Reference reference;//引用类型\r\n};\r\n\r\n\r\ntemplate<class _Ty, class _D>\r\nstruct _Bidit [主要是用于List中]: public iterator<bidirectional_iterator_tag,\r\n\t\t                       _Ty, _D> \r\n{};\r\n\r\ntemplate<class _Ty, class _D>\r\nstruct _Ranit : public iterator<random_access_iterator_tag,\r\n\t\t                        _Ty, _D> \r\n{};\r\ntemplate<class Iterator>\r\nstruct iterator_traits\r\n{[此步是真正的类型萃取]\r\n\t//iterator_traits()\r\n\t//{\r\n\t//\tstd::cout<<\"iterator<iteator>\"<<std::endl;\r\n\t//}\r\n\ttypedef typename Iterator::iterator_category iterator_category;\r\n\ttypedef typename Iterator::value_type        value_type;\r\n\ttypedef typename Iterator::difference_type   difference_type;\r\n\ttypedef typename Iterator::pointer           pointer;\r\n\ttypedef typename Iterator::reference         reference;\r\n};\r\n\r\ntemplate<class T>\r\nstruct iterator_traits<T*>\r\n{\r\n\t//iterator_traits()\r\n\t//{\r\n\t//\tstd::cout<<\"iterator<T*>\"<<std::endl;\r\n\t//}\r\n\ttypedef random_access_iterator_tag  iterator_category;\r\n\ttypedef T                           value_type;\r\n\ttypedef ptrdiff_t                   difference_type;\r\n\ttypedef T*                          pointer;\r\n\ttypedef T&                          reference;\r\n};\r\n    \r\n\r\ntemplate<class T>\r\nstruct iterator_traits<const T*>\r\n{\r\n\ttypedef random_access_iterator_tag  iterator_category;\r\n\ttypedef T                           value_type;\r\n\ttypedef ptrdiff_t                   difference_type;\r\n\ttypedef const T*                    pointer;\r\n\ttypedef const T&                    reference;\r\n};\r\n\r\ntemplate<class Iterator>\r\ninline typename iterator_traits<Iterator>::iterator_category\r\niterator_category(const Iterator &)\r\n{\r\n\t//iterator_traits<Iterator>();\r\n\ttypedef typename iterator_traits<Iterator>::iterator_category category;\r\n\treturn category();\r\n}\r\ntemplate<class Iterator>\r\ninline typename iterator_traits<Iterator>::difference_type *\r\ndistance_type(const Iterator &)\r\n{\r\n\treturn static_cast<typename iterator_traits<Iterator>::difference_type *>(0);\r\n}\r\n\r\ntemplate<class Iterator>\r\ninline typename iterator_traits<Iterator>::value_type *[之所以要用指针是由于我们可以明确指针的大小4字节，\r\n//如果返回对象的话可能会大于4字节，所以在此也考虑到了效率]\r\nvalue_type(const Iterator &)\r\n{\r\n\treturn static_cast<typename iterator_traits<Iterator>::value_type*>(0);\r\n}\r\n\r\ntemplate<class InputIterator>\r\ninline typename iterator_traits<InputIterator>::difference_type\r\n__distance(InputIterator first,InputIterator last, \r\n\t\t                       input_iterator_tag)\r\n{\r\n\ttypename iterator_traits<InputIterator>::difference_type n = 0;\r\n\tfor(; first != last; ++first)\r\n\t{\r\n\t\t++n;\r\n\t}\r\n\treturn n;\r\n}\r\n\r\n\r\ntemplate<class RandomAccessIterator>\r\ninline typename iterator_traits<RandomAccessIterator>::difference_type\r\n__distance(RandomAccessIterator  first,RandomAccessIterator last, \r\n\t\t                                     random_access_iterator_tag )\r\n{\r\n\treturn last-first;\r\n}\r\n\r\ntemplate<class InputIterator>\r\ninline typename iterator_traits<InputIterator>::difference_type\r\ndistance(InputIterator first,InputIterator last)\r\n{\r\n\ttypedef typename iterator_traits<InputIterator>::iterator_category category;\r\n\treturn __distance(first,last,category());\r\n}\r\n\r\n\r\n///////////////////////////////////////////////\r\ntemplate<class InputIterator,class Distance>\r\ninline void __advance(InputIterator &i,Distance n,\r\n\t\t\t\t\t  input_iterator_tag)\r\n{\r\n\twhile(n--) ++i;\r\n}\r\n\r\ntemplate<class BidirectionalIterator,class Distance>\r\ninline void __advance(BidirectionalIterator &i,Distance n,\r\n\t\t\t\t\t  bidirectional_iterator_tag)\r\n{\r\n\tif(n>=0)\r\n\t\twhile(n--) ++i;\r\n\telse\r\n\t\twhile(n++) --i;\r\n}\r\n\r\ntemplate<class RandomAccessIterator,class Distance>\r\ninline void __advance(RandomAccessIterator &i,Distance n,\r\n\t\t\t\t\t          random_access_iterator_tag)\r\n{\r\n\ti+=n;\r\n}\r\n\r\ntemplate<class InputIterator,class Distance>\r\ninline void advance(InputIterator &i,Distance n)\r\n{\r\n\t__advance(i,n,iterator_category(i));\r\n}\r\n```\r\n* 3：此技术的运用     \r\n   比方上面求差值函数distance(first，last)中调用的__distance(first,last,category())函数\r\n就是通过第三个参数来萃取出迭代器的类型，然后选择相应的函数，若是随机迭代器则_diss=last=fast;\r\n否则的话就要通过循环来累加了   \r\n\r\n\r\n三：STL之Find算法\r\n====\r\n首先是SGI版本的：      \r\n \r\n ``` c   \r\nTemplate<class iterator ,class T>\r\nIterator   find(Iterator  first , Iterator  last,const T &x)\r\n{\r\n\tWhile(first!=last &&*first!=x)\r\n{\r\n   ++first;\r\n}\r\nreturn first;\r\n}\r\nPG版本的\r\ntemplate<class _II, class _Ty> inline\r\n_II find(_II _F, _II _L, const _Ty& _V)\r\n{\r\nfor (; _F != _L; ++_F)\r\n\t\tif (*_F == _V)\r\n\t\t\tbreak;\r\n\treturn (_F); \r\n}\r\n```\r\n\r\n\r\n四：STL之search算法\r\n====\r\n注意：SGI的版本是比PG的版本高的  \r\n  SGI的思想就是：    \r\n1：首先计算出两个要比较的迭代器之间的差值记作为d1与d2   \r\n2：然后通过比较d1与d2的大小，若d1<d2 则直接返回last1    \r\n3：否则定义curent1=fast1   curent2=fast2 ，然后遍历第二个区间（即【fast2，last2】使用while（curent2！=last2）））    \r\n4：在while中若*current1==*current2  则都向后面跑   \r\n5：否则判断d1==d2是否满足，若满足则返回last1  \r\n6：否则重置curent2=fast2；curent1=++fast1 继续while循环    \r\n7：若退出循环则说明在【fast1，last1】中找到了与【fast2，last2】完全匹配的 返回fast1    \r\n\r\n* 首先是SGI版本的：  \r\n\r\n``` c\r\ntemplate<class _FI1, class _FI2> inline\r\n\t_FI1 search(_FI1 _F1, _FI1 _L1, _FI2 _F2, _FI2 _L2)//[意思是看F1到L1之间是否存在F2之L2完全匹配的子序列，若存在则返回F1否则返回L1]\r\n\t{return (_Search(_F1, _L1, _F2, _L2,\r\n\t\t_Dist_type(_F1), _Dist_type(_F2))); }\r\ntemplate<class _FI1, class _FI2, class _Pd1, class _Pd2> inline\r\n\t_FI1 _Search(_FI1 _F1, _FI1 _L1, _FI2 _F2 , _FI2 _L2,\r\n\t\t_Pd1 *, _Pd2 *)\r\n\t{_Pd1 d1 = 0;\r\n\t_Distance(_F1, _L1, _D1);\r\n\t_Pd2 d2 = 0;\r\n\t_Distance(_F2, _L2, _D2);\r\n  ///////////////////////////////////////////\r\n  If(d1<d2)return _L1;\r\n\r\n  _FI1 curent1=_F1;\r\n  _F2 curent2=_F2;\r\n \r\n  While(curent2!=L2)\r\n{\r\nIf(*curent1==*curent2)\r\n{\r\n  ++curent1;\r\n++curent2;\r\n}\r\nElse\r\n{\r\n  If(d1==d2) return L1;\r\n  Curent1=++F1;\r\n  Curent2=F2;\r\n  --d1;\r\n}\r\n\r\n}\r\n  Return F1;\r\n  \r\n}\r\n```\r\n\r\n* PG版本：\r\nPG的思想：其本质是和SGI是一样的，只不过是使用的是for循环，并且PG版本是在循环中找满足条件的，与SGI是相反的\r\n\r\n```c\r\ntemplate<class _FI1, class _FI2> inline\r\n\t_FI1 search(_FI1 _F1, _FI1 _L1, _FI2 _F2, _FI2 _L2)//[意思是看F1到L1之间是否存在F2之L2完全匹配的子序列，\r\n//若存在则返回F1否则返回L1]\r\n\t{return (_Search(_F1, _L1, _F2, _L2,\r\n\t\t_Dist_type(_F1), _Dist_type(_F2))); }\r\ntemplate<class _FI1, class _FI2, class _Pd1, class _Pd2> inline\r\n\t_FI1 _Search(_FI1 _F1, _FI1 _L1, _FI2 _F2, _FI2 _L2,\r\n\t\t_Pd1 *, _Pd2 *)\r\n\t{_Pd1 _D1 = 0;\r\n\t_Distance(_F1, _L1, _D1);\r\n\t_Pd2 _D2 = 0;\r\n\t_Distance(_F2, _L2, _D2);\r\n\tfor (; _D2 <= _D1; ++_F1, --_D1)\r\n\t\t{_FI1 _X1 = _F1;\r\n\t\tfor (_FI2 _X2 = _F2; ; ++_X1, ++_X2)\r\n\t\t\tif (_X2 == _L2)\r\n\t\t\t\treturn (_F1);\r\n\t\t\telse if (!(*_X1 == *_X2))\r\n\t\t\t\tbreak; }\r\n\treturn (_L1); }\r\n    ```\r\n\r\n五：STL之for_each（）算法\r\n====\r\n\r\n   主要用到的就是仿函数的思想以及模板实参推演技术    \r\n   ```c\r\nTemplate<class  T>\r\nStruct  Print\r\n{\r\n   Operator()(const T&x)\r\n{\r\n    Cout<<x<<”  ”;\r\n}\r\n};\r\n\r\nTemplate<class IT,class op>\r\nFor_each(IT I,IT L ,op fn)\r\n{\r\nfor(;I!=L;++I)\r\n{\r\n  fn(*I);\r\n}\r\n}、\r\n```\r\n\r\n六：STL的容器\r\n=====\r\n\r\n* 1：首先STL的所有关联容器都自动拥有排序功能（由于底层采用的是红黑树）所以不需要用到这个sort算法，\r\n对于序列容器stack  queue  priority_queue由于拥有特定的出入口，所以不允许对其排序，剩下的对于\r\nvector  deque  list 前两者属于随机迭代器适合使用sort而list自己拥有sort排序方法  \r\n\r\n* 2:vector底层使用的是数据组实现的，stack和queue底层使用的是list[是双向迭代器]    \r\n\r\n* 3：注意list与vector的clear函数的区别，首先vector中的clear 只是把finish修改而且调用了析构函数\r\n但是没有释放空间，但是list中的clear却不但要调用析构函数而且还要释放空间（其主要原因是：由于\r\nvector是连续空间 而 list却不是连续的空间所以每当删除某一个节点的时候就要释放其空间不然就会造\r\n成内存泄露）     \r\n\r\n* 4：注意stack以及queue  priority_queue没有迭代器     \r\n\r\n\r\n七：绑定器的介绍\r\n======\r\n   首先绑定器分为一元绑定器与二元绑定器   \r\n   一元绑定器：就是把函数的第一个参数和函数绑定起来    \r\n   二元绑定器：就是把函数的第二个参数与函数绑定起来   \r\n\r\n实现方法就是：以下是二元绑定器实例：  \r\n``` c\r\n#if 0\r\ntemplate<class _A1, class _A2, class _R>\r\nstruct binary_function \r\n{\r\n\ttypedef _A1 first_argument_type;\r\n\ttypedef _A2 second_argument_type;\r\n\ttypedef _R  result_type;\r\n};\r\n\r\ntemplate<class _Ty>\r\nstruct less : binary_function<_Ty, _Ty, bool> \r\n{\r\n\tbool operator()(const _Ty& _X, const _Ty& _Y) const\r\n\t{\r\n\t\treturn (_X < _Y); \r\n\t}\r\n};\r\n#endif\r\n//////////////////////////////\r\n\r\n\r\ntemplate<class _Bfn>\r\nstruct  binder2nd :\r\n       public binary_function<_Bfn::first_argument_type,\r\n\t\t                      _Bfn::second_argument_type,\r\n\t\t\t\t\t\t\t  _Bfn::result_type>\r\n{\r\n\t_Bfn op;\r\n\t_Bfn::second_argument_type value;\r\npublic:\r\n\tbinder2nd(const _Bfn &_X,\r\n\t\tconst _Bfn::second_argument_type &_Y)\r\n\t\t:op(_X),value(_Y)\r\n\t{}\r\n\t_Bfn::result_type operator()(_Bfn::first_argument_type &_X)\r\n\t{\r\n\t\treturn op(_X,value);\r\n\t}\r\n};\r\n\r\ntemplate<class _Bfn,class _Ty> [//此步是为了解决二货的人给的如：binder2nd<less<int>> (less<double>(),4)  两个类型不一致\r\n]\r\nbinder2nd<_Bfn> bind2nd(const _Bfn &_X,const _Ty &_Y)//用binder2nd<_Bfn> 定义对象bind2nd\r\n{\r\n\treturn binder2nd<_Bfn>(_X,(_Bfn::second_argument_type)_Y);\r\n\r\n}//   binder2nd<less<int>> (less<int>(),4)     bind2nd(less<int>(),4)\r\n\r\ntemplate<class _Ty,class _Bfn>\r\nvoid Show(_Ty *ar,int n,_Bfn _Fn)\r\n{\r\n\tfor(int i=0;i<n;++i)\r\n\t{\r\n\t\tif(_Fn(ar[i]))\r\n\t\t{\r\n\t\t\tcout<<ar[i]<<\"  \";\r\n\t\t}\r\n\t}\r\n\tcout<<endl;\r\n}\r\nvoid main()\r\n{\r\n\tint ar[10]={1,2,3,4,5,6,7,8,9,10};\r\n\tgreater<int> gt;\r\n\tless<int> ls;\r\n\tShow(ar,10,bind2nd(less<int>(),4));\r\n}\r\n```\r\n八：STL各种容器的比较\r\n======\r\n* 1 vector  \r\n向量 相当于一个数组   \r\n注意： \r\n  _First是指指向数组的第一个元素   \r\n  _Last是指有效元素的下一个位置     \r\n  _End是指所有空间最后的下一个位置     \r\n    在内存中分配一块连续的内存空间进行存储。支持不指定vector大小的存储。STL内部实现时，\r\n首先分配一个非常大的内存空间预备进行存储，即capacituy（）函数返回的大小，当超过此分配\r\n的空间时再整体重新放分配一块内存存储，这给人以vector可以不指定vector即一个连续内存的大\r\n小的感觉。通常此默认的内存分配能完成大部分情况下的存储。     \r\n  * 优点：\r\n         (1) 不指定一块内存大小的数组的连续存储，即可以像数组一样操作，但可以对此数组 \r\n进行动态操作。通常体现在push_back() pop_back()\r\n         (2) 随机访问方便，即支持[ ]操作符和vector.at()\r\n         (3) 节省空间。\r\n *  缺点：\r\n         (1) 在内部进行插入删除操作效率低。\r\n         (2) 只能在vector的最后进行push和pop，不能在vector的头进行push和pop。\r\n         (3) 当动态添加的数据超过vector默认分配的大小时要进行整体的重新分配、拷贝与释放\r\n                     \r\n* 2 list\r\n    双向链表    \r\n    每一个结点都包括一个信息快Info、一个前驱指针Pre、一个后驱指针Post。\r\n可以不分配必须的内存大小方便的进行添加和删除操作。使用的是非连续的内存\r\n空间进行存储   。   \r\n *  优点：   \r\n         (1) 不使用连续内存完成动态操作。  \r\n         (2) 在内部方便的进行插入和删除操作   \r\n         (3) 可在两端进行push、pop   \r\n *  缺点：\r\n         (1) 不能进行内部的随机访问，即不支持[ ]操作符和vector.at()  \r\n         (2) 相对于verctor占用内存多  \r\n\r\n* 3 deque\r\n   双端队列 double-end queue  \r\n   deque是在功能上合并了vector和list。   \r\n  * 优点：    \r\n         (1) 随机访问方便，即支持[ ]操作符和vector.at()    \r\n         (2) 在内部方便的进行插入和删除操作   \r\n         (3) 可在两端进行push、pop   \r\n  * 缺点：    \r\n        (1) 占用内存多   \r\n\r\n使用区别：   \r\n     1 如果你需要高效的随即存取，而不在乎插入和删除的效率，使用vector    \r\n     2 如果你需要大量的插入和删除，而不关心随即存取，则应使用list    \r\n     3 如果你需要随即存取，而且关心两端数据的插入和删除，则应使用deque    \r\n\r\n\r\n\r\n九：STL总的概述\r\n======\r\n\r\nSTL提供六大组件，彼此可以组合套用   \r\n\r\n* 1、容器（containers）：各种数据结构，如vertor，list，deque，set，map.从实现的角度来看，\r\nSTL容器是一种class template    \r\n\r\n* 2、算法（algorithms）：各种算法如sort，search，copy，earse。STL算法是一种 function template。\r\n\r\n* 3、迭代器（iterators）：扮演容器与算法之间的胶合剂，是所谓的“泛型指针”。所有STL容器都有自己\r\n的专属的迭代器。   \r\n\r\n* 4、仿函数（functors）：行为类似函数，可以作为算法的某些策略。从实现的角度来看，仿函数是一种\r\n 重载了operator()的class或class template。    \r\n\r\n* 5、配接器（adapters实际上是一种设计模式）[即将一个class的接口转化为另一个class的接口，使其原\r\n 来不兼容的接口变成可以合作的；  \r\n\r\n通常使用两种方法可以完成\r\n\r\n* 方法一：\r\n   增加一个daapter类 ，然后使其公有继承类1私有继承类2，然后在重写类1的方法    \r\n\r\n* 方法二：\r\n   增加一个daapter类 ，然后使其公有继承类1，把类2作为自己的子对象，然后在\r\n重写类1的方法里面调用类2的新方法   \r\n\r\n]：一种用来修饰容器或仿函数或迭代器借口的东西。例如queue和stack      \r\n\r\n* 6、配置器（allocators）：负责空间的配置与管理。配置器是一个实现了动态空间分配、空间管理、\r\n空间释放的class template。   \r\n\r\n\r\n欢迎一起交流　　　　\r\n====\r\n \r\n在使用中有任何问题，欢迎反馈给我，可以用以下联系方式跟我交流\r\n\r\n* 邮件(1031379296#qq.com, 把#换成@)\r\n* QQ: 1031379296\r\n* weibo: [@王发康](http://weibo.com/u/2786211992/home)\r\n\r\n\r\nThx\r\n====\r\n\r\n* chunshengsterATgmail.com\r\n\r\n\r\nAuthor\r\n====\r\n* Linux\\nginx\\golang\\c\\c++爱好者\r\n* 欢迎一起交流  一起学习# \r\n* Others say good and Others good\r\n","google":"c++ STL  stl containers　algorithms　allocators　adapters　analysis","note":"Don't delete this file! It's used internally to help with page regeneration."}